y = col,
color = "Artist Popularity") +
theme_minimal()
# Create scatter plots with hexagonal binning
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = track_popularity, y = danceability)) +
geom_hex(bins = 30) +
scale_fill_gradient(low = "blue", high = "red") +  # Specify colors
labs(title = paste(col),
x = "Track Popularity",
y = col,
color = "Artist Popularity") +
theme_minimal()
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
ggplot(merged_df, aes(x = track_popularity, y = get(col), group = relative_pop, fill = relative_pop)) +
geom_density2d() +
scale_fill_gradient(low = "blue", high = "red") +  # Specify colors
labs(title = paste(col),
x = "Track Popularity",
y = col,
color = "Artist Popularity") +
theme_minimal()
ggplot(merged_df, aes(x = track_popularity, y = get(col), group = relative_pop, fill = relative_pop)) +
geom_density2d() +
#scale_fill_gradient(low = "blue", high = "red") +  # Specify colors
labs(title = paste(col),
x = "Track Popularity",
y = col,
color = "Artist Popularity") +
theme_minimal()
ggplot(merged_df, aes(x = track_popularity, y = get(col), group = relative_pop, fill = relative_pop)) +
geom_density() +
#scale_fill_gradient(low = "blue", high = "red") +  # Specify colors
labs(title = paste(col),
x = "Track Popularity",
y = col,
color = "Artist Popularity") +
theme_minimal()
ggplot(merged_df, aes(x = track_popularity, y = get(col), group = relative_pop, fill = relative_pop)) +
geom_density_2d() +
labs(title = paste(col),
x = "Track Popularity",
y = col,
fill = "Relative Popularity") +
theme_minimal()
ggplot(merged_df, aes(x = get(col), fill = relative_pop)) +
geom_density(alpha = 0.5) +
labs(title = paste("Density Plot of", col),
x = col,
fill = "Relative Popularity") +
theme_minimal()
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = get(col), fill = relative_pop)) +
geom_density(alpha = 0.5) +
labs(title = paste("Density Plot of", col),
x = col,
fill = "Relative Popularity") +
theme_minimal()
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = get(col), fill = relative_pop)) +
geom_density(alpha = 0.3) +
labs(title = paste("Density Plot of", col),
x = col,
fill = "Relative Popularity") +
theme_minimal()
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
library(RColorBrewer)
# Create a blue-to-red color palette
colors <- brewer.pal(9, "RdBu")
# Reverse the color order to go from blue to red
colors <- rev(colors)
library(RColorBrewer)
# Create a blue-to-red color palette
colors <- brewer.pal(9, "RdBu")
# Create a blue-to-red color palette
colors <- brewer.pal(9, "RdBu")
# Reverse the color order to go from blue to red
colors <- rev(colors)
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = get(col), fill = relative_pop)) +
geom_density(alpha = 0.3) +
scale_fill_manual(values = colors) +
labs(title = paste("Density Plot of", col),
x = col,
fill = "Relative Popularity") +
theme_minimal()
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
# Define a custom color palette
custom_colors <- c("#88CCEE", "#44AA99", "#117733", "#332288")
# Use the chosen colors in the plot
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = get(col), fill = relative_pop)) +
geom_density(alpha = 0.3) +
scale_fill_manual(values = custom_colors) +
labs(title = paste("Density Plot of", col),
x = col,
fill = "Relative Popularity") +
theme_minimal()
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
# Define a custom color palette
custom_colors <- c("#1F78B4", "#FF7F00")
# Use the chosen colors in the plot
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = get(col), fill = relative_pop)) +
geom_density(alpha = 0.3) +
scale_fill_manual(values = custom_colors) +
labs(title = paste("Density Plot of", col),
x = col,
fill = "Relative Popularity") +
theme_minimal()
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
# Use the chosen colors in the plot
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = get(col), fill = track_popularity)) +
geom_density(alpha = 0.3) +
scale_fill_manual(values = custom_colors) +
labs(title = paste("Density Plot of", col),
x = col,
fill = "Relative Popularity") +
theme_minimal()
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
ggplot(merged_df, aes(x = get(col), fill = is_track_pop)) +
geom_density(alpha = 0.3) +
scale_fill_manual(values = custom_colors) +
labs(title = paste("Density Plot of", col),
x = col,
fill = "Relative Popularity") +
theme_minimal()
# Use the chosen colors in the plot
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = get(col), fill = is_track_pop)) +
geom_density(alpha = 0.3) +
scale_fill_manual(values = custom_colors) +
labs(title = paste("Density Plot of", col),
x = col,
fill = "Relative Popularity") +
theme_minimal()
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
# Use the chosen colors in the plot
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = get(col), fill = is_track_pop)) +
geom_density(alpha = 0.3) +
scale_fill_manual(values = custom_colors) +
labs(title = paste("Density Plot of", col),
x = col,
fill = "Relative Popularity") +
theme_minimal()+
theme(legend.position = "bottom")
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
merged_df
View(merged_df)
artist_info_ranking$is_popular <- ifelse(artist_info_ranking$popularity > 50, "Popular", "Not Popular")
subset_artist_pop <- artist_info_ranking %>% select(artist_id = id, artist_popularity = popularity, relative_pop, is_popular)
merged_df <- merge(merged_df, subset_artist_pop, by = "artist_id")
merged_df$is_track_pop <- ifelse(merged_df$track_popularity > 50, "Popular Song", "Unpopular Song")
# Use the chosen colors in the plot
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = get(col), fill = is_popular)) +
geom_density(alpha = 0.3) +
scale_fill_manual(values = custom_colors) +
labs(title = paste("Density Plot of", col),
x = col,
fill = "Relative Popularity") +
theme_minimal()+
theme(legend.position = "bottom")
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
# Use the chosen colors in the plot
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = get(col), fill = is_popular)) +
geom_density(alpha = 0.3) +
scale_fill_manual(values = custom_colors) +
labs(title = paste("Density Plot of", col),
x = col,
fill = ) +
theme_minimal()+
theme(legend.position = "bottom")
})
# Use the chosen colors in the plot
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = get(col), fill = is_popular)) +
geom_density(alpha = 0.3) +
scale_fill_manual(values = custom_colors) +
labs(title = paste("Density Plot of", col),
x = col) +
theme_minimal()+
theme(legend.position = "bottom")
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
# Use the chosen colors in the plot
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = get(col), fill = is_track_pop)) +
geom_density(alpha = 0.3) +
scale_fill_manual(values = custom_colors) +
labs(title = paste("Density Plot of", col),
x = col,
fill = "Relative Popularity") +
theme_minimal()+
theme(legend.position = "bottom")
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
ggplot(merged_df, aes(x = get(col), fill = is_track_pop)) +
geom_density(alpha = 0.3) +
scale_fill_manual(values = custom_colors) +
labs(title = paste("Density Plot of", col),
x = col,
fill = "Relative Popularity") +
theme_minimal()+
theme(legend.position = "bottom")
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
#Plotting based on artist popularity
plots <- lapply(scatter_cols, function(col) {
ggplot(merged_df, aes(x = get(col), fill = is_popular)) +
geom_density(alpha = 0.3) +
scale_fill_manual(values = custom_colors) +
labs(title = paste("Density Plot of", col),
x = col) +
theme_minimal()+
theme(legend.position = "bottom")
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
colnames(merged_df)
# Subset the data frame to include only the relevant columns
subset_df <- merged_df[c("danceability", "energy", "key", "loudness", "mode", "speechiness", "acousticness", "instrumentalness", "liveness", "valence", "tempo", "artist_popularity")]
# Subset the data frame to include only the relevant columns
subset_df <- merged_df[c("danceability", "energy", "key", "loudness", "mode", "speechiness", "acousticness", "instrumentalness", "liveness", "valence", "tempo", "artist_popularity.x")]
# Subset the data frame to include only the relevant columns
subset_df <- merged_df[c("danceability", "energy", "key", "loudness", "mode", "speechiness", "acousticness", "instrumentalness", "liveness", "valence", "tempo", "artist_popularity.x")]
# Fit a multiple linear regression model
model <- lm(artist_popularity ~ ., data = subset_df)
# Fit a multiple linear regression model
model <- lm(artist_popularity.x ~ ., data = subset_df)
# Display the summary of the regression model
summary(model)
# Install and load necessary packages (if not already installed)
if (!requireNamespace("ggplot2", quietly = TRUE)) {
install.packages("ggplot2")
}
if (!requireNamespace("cowplot", quietly = TRUE)) {
install.packages("cowplot")
}
library(ggplot2)
library(cowplot)
# Create diagnostic plots
diagnostic_plots <- function(model) {
# Residuals vs Fitted
plot1 <- ggplot(model, aes(fitted.values, residuals)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(title = "Residuals vs Fitted", x = "Fitted values", y = "Residuals")
# Normal Q-Q Plot
plot2 <- ggplot(model, aes(sample = residuals)) +
stat_qq() +
stat_qq_line() +
labs(title = "Normal Q-Q Plot", x = "Theoretical Quantiles", y = "Sample Quantiles")
# Scale-Location (Square Root of Standardized Residuals) vs Fitted
plot3 <- ggplot(model, aes(fitted.values, sqrt(abs(residuals)))) +
geom_point() +
geom_smooth(se = FALSE, method = "loess", formula = y ~ x) +
labs(title = "Scale-Location Plot", x = "Fitted values", y = "Square Root of Standardized Residuals")
# Residuals vs Leverage
plot4 <- ggplot(model, aes(hatvalues, residuals)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(title = "Residuals vs Leverage"
# Install and load necessary packages (if not already installed)
if (!requireNamespace("ggplot2", quietly = TRUE)) {
install.packages("ggplot2")
}
if (!requireNamespace("cowplot", quietly = TRUE)) {
install.packages("cowplot")
}
library(ggplot2)
library(cowplot)
# Create diagnostic plots
diagnostic_plots <- function(model) {
# Residuals vs Fitted
plot1 <- ggplot(model, aes(fitted.values, residuals)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(title = "Residuals vs Fitted", x = "Fitted values", y = "Residuals")
# Normal Q-Q Plot
plot2 <- ggplot(model, aes(sample = residuals)) +
stat_qq() +
stat_qq_line() +
labs(title = "Normal Q-Q Plot", x = "Theoretical Quantiles", y = "Sample Quantiles")
# Scale-Location (Square Root of Standardized Residuals) vs Fitted
plot3 <- ggplot(model, aes(fitted.values, sqrt(abs(residuals)))) +
geom_point() +
geom_smooth(se = FALSE, method = "loess", formula = y ~ x) +
labs(title = "Scale-Location Plot", x = "Fitted values", y = "Square Root of Standardized Residuals")
# Residuals vs Leverage
plot4 <- ggplot(model, aes(hatvalues, residuals)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(title = "Residuals vs Leverage", x = "Leverage", y = "Residuals")
# Combine plots into a grid
plot_grid(plot1, plot2, plot3, plot4, ncol = 2, labels = "AUTO")
}
# Call the function with your regression model
diagnostic_plots(model)
# Subset the data frame to include only the relevant columns
subset_df <- merged_df[c("danceability", "energy", "key", "loudness", "mode", "speechiness", "acousticness", "instrumentalness", "liveness", "valence", "tempo", "artist_popularity.x")]
# Fit a multiple linear regression model
model <- lm(artist_popularity.x ~ ., data = subset_df)
# Display the summary of the regression model
summary(model)
# Install and load necessary packages (if not already installed)
if (!requireNamespace("ggplot2", quietly = TRUE)) {
install.packages("ggplot2")
}
if (!requireNamespace("cowplot", quietly = TRUE)) {
install.packages("cowplot")
}
library(ggplot2)
library(cowplot)
# Create diagnostic plots
diagnostic_plots <- function(model) {
# Residuals vs Fitted
plot1 <- ggplot(model, aes(fitted.values, residuals)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(title = "Residuals vs Fitted", x = "Fitted values", y = "Residuals")
# Normal Q-Q Plot
plot2 <- ggplot(model, aes(sample = residuals)) +
stat_qq() +
stat_qq_line() +
labs(title = "Normal Q-Q Plot", x = "Theoretical Quantiles", y = "Sample Quantiles")
# Scale-Location (Square Root of Standardized Residuals) vs Fitted
plot3 <- ggplot(model, aes(fitted.values, sqrt(abs(residuals)))) +
geom_point() +
geom_smooth(se = FALSE, method = "loess", formula = y ~ x) +
labs(title = "Scale-Location Plot", x = "Fitted values", y = "Square Root of Standardized Residuals")
# Residuals vs Leverage
plot4 <- ggplot(model, aes(hatvalues, residuals)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(title = "Residuals vs Leverage", x = "Leverage", y = "Residuals")
# Combine plots into a grid
plot_grid(plot1, plot2, plot3, plot4, ncol = 2, labels = "AUTO")
}
# Call the function with your regression model
diagnostic_plots(model)
# Assuming your model was created using lm function
model <- lm(artist_popularity ~ ., data = subset_df)
# Assuming your model was created using lm function
model <- lm(artist_popularity.x ~ ., data = subset_df)
# Call the function with your regression model
diagnostic_plots(model)
# Install and load necessary packages (if not already installed)
if (!requireNamespace("ggplot2", quietly = TRUE)) {
install.packages("ggplot2")
}
if (!requireNamespace("cowplot", quietly = TRUE)) {
install.packages("cowplot")
}
library(ggplot2)
library(cowplot)
# Define diagnostic_plots function
diagnostic_plots <- function(data, dependent_var, independent_vars) {
# Fit a multiple linear regression model
model <- lm(paste(dependent_var, "~", paste(independent_vars, collapse = " + ")), data = data)
# Residuals vs Fitted
plot1 <- ggplot(model, aes(fitted.values, residuals)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(title = "Residuals vs Fitted", x = "Fitted values", y = "Residuals")
# Normal Q-Q Plot
plot2 <- ggplot(model, aes(sample = residuals)) +
stat_qq() +
stat_qq_line() +
labs(title = "Normal Q-Q Plot", x = "Theoretical Quantiles", y = "Sample Quantiles")
# Scale-Location (Square Root of Standardized Residuals) vs Fitted
plot3 <- ggplot(model, aes(fitted.values, sqrt(abs(residuals)))) +
geom_point() +
geom_smooth(se = FALSE, method = "loess", formula = y ~ x) +
labs(title = "Scale-Location Plot", x = "Fitted values", y = "Square Root of Standardized Residuals")
# Residuals vs Leverage
plot4 <- ggplot(model, aes(hatvalues, residuals)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(title = "Residuals vs Leverage", x = "Leverage", y = "Residuals")
# Combine plots into a grid
plot_grid(plot1, plot2, plot3, plot4, ncol = 2, labels = "AUTO")
}
# Call the function with your data frame and variable names
diagnostic_plots(subset_df, "artist_popularity", c("danceability", "energy", "key", "loudness", "mode", "speechiness", "acousticness", "instrumentalness", "liveness", "valence", "tempo"))
# Call the function with your data frame and variable names
diagnostic_plots(subset_df, "artist_popularity.x", c("danceability", "energy", "key", "loudness", "mode", "speechiness", "acousticness", "instrumentalness", "liveness", "valence", "tempo"))
# Assuming df1 is audio_features_us and df2 is artist_info_ranking
# Merge the dataframes based on artist_spotify
merged_df <- merge(audio_features_us, artist_info_ranking, by = "artist_spotify")
# Create a new column to identify relative_pop artists
merged_df$relative_pop <- ifelse(merged_df$relative_pop == "Popular", "Yes", "No")
# Load required libraries
library(ggplot2)
library(patchwork)
# Select relevant columns for comparison
comparison_cols <- c("danceability", "energy", "key", "loudness", "mode",
"speechiness", "acousticness", "instrumentalness",
"liveness", "valence", "tempo")
# Create side-by-side box plots in a grid with 3 columns
plots <- lapply(comparison_cols, function(col) {
ggplot(merged_df, aes(x = relative_pop, y = get(col), fill = relative_pop)) +
geom_boxplot() +
labs(title = paste(col),
x = "Popularity",
y = col) +
theme_minimal() +
theme(legend.position = "none")  # Remove legend for clarity
})
# Arrange plots in a grid with 3 columns
grid_plots <- wrap_plots(plots, ncol = 3)
# Display the grid of plots
print(grid_plots)
library(jsonlite)
json_file_path <- "C:\Ed\Mestrado_aulas\AT_MY472_Data_for_Data_Scientists\Assignments\MY_472_Final_Assignment\data\artist"
json_file_path <- "C:\\Ed\\Mestrado_aulas\\AT_MY472_Data_for_Data_Scientists\\Assignments\\MY_472_Final_Assignment\\data\\artist"
# Read the JSON file
json_data <- fromJSON(json_file_path)
json_file_path <- "C:/Users/edimi/Downloads/artist.tar.xz/mbdump/artist"
# Read the JSON file
json_data <- fromJSON(json_file_path)
json_file_path <- "C:\\Users\\edimi\\Downloads\\artist.tar.xz\\mbdump\\artist"
# Read the JSON file
json_data <- fromJSON(json_file_path)
file_path <- "C:\\Users\\edimi\\Downloads\\artist.tar.xz"
untar(file_path, verbose = TRUE)
library(jsonlite)
# Specify the complete path to the JSON file
json_file_path <- "C:\\Users\\edimi\\Downloads\\artist\\mbdump\\artist"
# Read the JSON file
json_data <- fromJSON(json_file_path)
# Specify the complete path to the JSON file
json_file_path <- "C:\\Users\\edimi\\Downloads\\artist\\mbdump\\artist.json"
# Read the JSON file
json_data <- fromJSON(json_file_path)
# Read the JSON file
json_data <- stream_in(file(json_file_path, "r"))
# Read the JSON file
json_data <- stream_in(file(json_file_path, "r"), n_max = 100)
json_file_path <- "C:/Users/edimi/Downloads/artist/mbdump/artist.json"
# Read the first 100 JSON objects from the file
json_data <- stream_in(file(json_file_path, "r"), n_max = 100)
# Open the file for reading
con <- file(json_file_path, "r")
con
# Read the first 100 JSON objects
json_data <- stream_in(con, pagesize = 100)
json_file_path <- "C:/Users/edimi/Downloads/artist/mbdump/artist.json"
# Specify the number of records to read
records_to_read <- 100
# Read the specified number of lines from the file
json_lines <- readLines(json_file_path, n = records_to_read)
# Combine the lines into a single string
json_text <- paste(json_lines, collapse = "")
# Parse the JSON data
json_data <- fromJSON(json_text)
json_lines
gc()
